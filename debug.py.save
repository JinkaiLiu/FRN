import torch
import torch.nn as nn
import numpy as np

def inspect_conv_layer(layer):
    print("====== 模型卷积层参数 ======")
    print(f"Layer: {layer}")
    print(f"Weight shape: {layer.weight.shape}")  # [out_channels, in_channels, kernel_H, kernel_W]
    in_channels = layer.weight.shape[1]
    print(f"Expected input channels: {in_channels}")
    return in_channels

def inspect_img_event(img_event):
    print("====== 当前 img_event 数据格式 ======")
    print(f"img_event shape: {img_event.shape}")
    B, N, C = img_event.shape
    print(f"Batch size: {B}")
    print(f"Total voxel count per sample: {N}")
    print(f"Input channel: {C}")
    return B, N, C

def try_reshape(img_event, in_channels, H_list=[128, 96, 64]):
    B, N, C = img_event.shape
    print("\n====== 尝试匹配 reshape 格式 ======")
    for H in H_list:
        for T in [in_channels]:
            W = N // (T * H)
            if T * H * W == N:
                print(f"✅ 可以 reshape 为: [{B}, {T}, {H}, {W}]")
                return (T, H, W)
    print("❌ 无法找到合适的 T, H, W 组合匹配 reshape")
    return None

# 示例：加载模型和一个 batch 的 img_event
if __name__ == "__main__":
    # 加载你的模型
    from retinanet.model import resnet50  # 你模型初始化的方法
    model = resnet50(num_classes=2, fusion')
    model.eval()

    # 模拟一批 img_event 输入
    # 替换成你真实的一批数据，例如通过 dataloader 拿一批
    B = 2
    N = 5 * 128 * 128  # 假设数据是 voxel grid, T=5, H=W=128
    C = 1
    img_event = torch.randn(B, N, C)

    # 1. 检查模型输入
    in_channels = inspect_conv_layer(model.conv1_event)

    # 2. 检查你的 img_event
    inspect_img_event(img_event)

    # 3. 尝试 reshape 成模型需要的格式
    try_reshape(img_event, in_channels)
